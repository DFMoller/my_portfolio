<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#4f8a96" />

    		<!-- To display on LinkedIn -->
    <meta property='og:title' content='My Portfolio'/>
    <meta property='og:image' content='img/featured_img.PNG'/>
    <meta property='og:description' content='Some things about me...'/>
    <meta property='og:url' content='https://danielmoller.co.za/'/>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="projects.css">
    <script src="projects.js"></script>

    <title>Projects</title>
</head>
<body>

    <nav>
        <header>
            <div class="home-box">
                <img src="../img/home.png" alt="home_icon">
                <a href="../index.html" target="_blank">Portfolio</a>
            </div>
            
            <div id="title-box">
                <!-- <div id="title-icon"><img src="../img/iconmonstr-archive-box-thin-240.png"></div> -->
                <h1>PROJECTS</h1>
            </div>
        </header>

        <menu>
            <div class="project-button" data-target="cloak1"><p>Building my Portfolio Website</p></div>
            <div class="project-button" data-target="cloak2"><p>Analyzing Vehicle Suspension</p></div>
            <div class="project-button" data-target="cloak3"><p>Some Kickass Recipes</p></div>
            <div class="project-button" data-target="cloak4"><p>Sensor Data Logging with Arduino and Blynk</p></div>
            <div class="project-button" data-target="cloak5"><p>Stepper Motor Control with ESP32, Arduino and AWS IoT Core</p></div>
            <div class="project-button" data-target="cloak6"><p>LCD Weather module with Arduino and OpenWeatherMap API</p></div>
        </menu>

    </nav>

    <main>
        <div class="mobile-head-cloak">
            <div class="mobile-head">
                <img src="../img/down-arrow.png" alt="hamburger">
                <p>Select Project</p>
            </div>
        </div>
        

        <div class="hamburger-circle">
            <label class="menu-icon">
                <span class="menu-lines">
                    <!-- <span class="hamburger-circle"></span> -->
                </span>
            </label>
        </div>


        <div class="cloak cloak1 hidden">
             <section id="project1" class="project">
                <div class="cover cover1">
                    <!-- <img src="../img/projects/website-screenshot.PNG" class="cover" alt="website"> -->
                </div>
                <div class="text">
                    <h1 class="title">Building my Portfolio Website</h1>
                    <p class="intro">I decided to build a website to serve as my Mechatronic Engineering portfolio. This is how it happened.</p>
                    <p class="paragraphs">2020 gave us the Covid-19 lockdown in South Africa and it is no secret that this virus impacted the lives of just about everyone on the planet in a substantial way. I was lucky enough to keep on living somewhat cumfortably and decided to work on some of my skills in the time before classes resumed at Stellenbosch Univerity. One of the topics I persued in this time was web development and I was particularily interested in front end web development. Simply put, I had no idea how a website interface was built and wanted to find out. At this point I already knew that my end goal was to create my own portfolio website and regardless of whether or not I was going to finish it, it was going to be the best way to learn the skills I was looking for.<br><br>
                    
                    I started learning by following different free example tutorials on <a href="https://www.youtube.com/" target="_blank">YouTube</a>, copying all the steps as I went along. When I understood the very basics, I moved to a <a href="https://www.skillshare.com/home" target="_blank">Skill Share</a> course which was very insightful. This is also how I learned to use Github repos and hosting. After that course, I felt I had enough knowledge to start making my own web pages and I spent most of my time following <a href="https://www.youtube.com/channel/UClb90NQQcskPUGDIXsQEz5Q/featured" target="_blank">Dev Ed</a>'s (his name is Ed) YouTube tutorials. He has a fantastic YouTube channel with many videos focusing on web development. That is where I learned how to use the little JavaScript animations seen on my website.<br><br>

                    My favourite elements of my website are the sliding animations used in the 'University' and 'Projects' sections. They use a JQUERY plugin, <a href="#">ScrollMagic</a>, to let animations start depending on the scrolling input of the user. I tried to stay away from plugins for the most part, just so that I could learn the basics and not take too many short cuts. But I used ScrollMagic, because it is a very powerful tool if you know how to use it. It also taught me a bit about plugins in general.<br><br>

                    Something else I really enjoyed making, was my cover gif. I did the drawing and animation of the bird in Procreate on an Ipad. I never realized it was so easy to illustrate and animate something simple like bird you can see below.<br>

                    <img src="../img/projects/website/canoe.gif" class="inner-img-landscape" alt="Canoe_gif">
                    
                    I have always wanted to know how websites are built from scratch and I have definitely in gaining that understanding. My interest in web development has since led me to a different project, <a href="https://recipes-ea247.web.app/" target="_blank">Some Kickass Recipes</a>, which is a PWA that can also be found in this projects library of mine.
                    </p>
                </div>
            </section>
        </div>
       

        <div class="cloak cloak2 hidden">
            <section id="project2" class="project">
                <div class="cover cover2"></div>
                <div class="text">
                    <h1 class="title">Analyzing Vehicle Suspension</h1>
                    <p class="intro">In this modelling experiment, the goal was to determine the sping constant and dampening coefficient for the suspension of a given passenger vehicle through visual analysis.</p>
                    <p class="paragraphs">The vehicle was set up by parking one wheel elevated on three garden tiles. The data was captured by reversing off the tiles while recording from a camera on a tripod to the side and the video footage was analyzed in a program called Tracker. This software can track and plot fixed points from frame to frame, which is why there were two stickers on the side of the car at the start of the experiment. One on the body of the car and one in the center of the wheel.<br><br>
                    
                    With the data from tracker, MatLab was used to subtract the heights from each other and form a new plot. At this point, the data was in a workable state and modelling formulas and calculations could be used to determine the required parameters.</p>
                </div>
            </section>
        </div>
        
        <div class="cloak cloak3 hidden">
            <section id="project3" class="project">
                <div class="cover cover3"></div>
                <div class="text">
                    <h1 class="title">Some Kickass Recipes</h1>
                    <p class="intro">This is my first PWA (progressive web application) that I have built. Users can create an account, sign in and start uploading recipes. Recipes can be made public or private. Public recipes can be viewed in the community section.</p>
                    <p class="paragraphs">This is my first functional PWA (Progressive Web Application). PWA's are web applications with additional advanced functionality that allow them to behave exactly like native apps. This includes the ability to cache data to improve the user experience. Loading times are decreased and this also allows a PWA to be used while offline. This is in strong contrast with standard web applications. Additionally, PWA's allow for the use of push notifications and they are able to access mobile device features such as the camera.<br><br>

                    Building native applications traditionally requires of one to know programming languages other than HTML, CSS and JS (which are used for building websites). However, PWA's can be built using these three popular languages, which removes the need to learn a new language like Java altogether.<br><br>
                        
                    Building <a href="https://recipes-ea247.web.app/" target="_blank">Some Kickass Recipes</a> and all its functionality has taught me the skills required to expand existing web applications into PWA's and I am excited by the doors that have opened for me as a result.</p>
                </div>
            </section>
        </div>

        <div class="cloak cloak4 hidden">
            <section id="project4" class="project">
                <div class="cover cover4"></div>
                <div class="text">
                    <h1 class="title">Sensor Data Logging with Arduino and Blynk</h1>
                    <p class="intro">In this project, I used Blynk to log data being read from three different motion sensors and to export this data to Excel for analysis.</p>
                    <p class="paragraphs"><a href="https://blynk.io/" target="_blank">Blynk</a> is a "hardware agnostic IoT platform" useful with device management, data analytics, machine learning and more. Finding blynk has been one of my best discoveries considering how much it has helped me and I am amazed by how easy it makes it to perform IoT tasks. Blynk supports over 400 hardware modules including all Arduino boars and more. As an exercise to play around with different features, I decided I would conduct an experiment to determine which of three motion sensors I had available were the best at different ranges.<br><br>
                    
                    The three sensors I had were the SR602 mini PIR sensor, the HC-SR501 PIR sensor and the RCWL-0516 Microwave Radar Sensor. I used the Arduino Nano 33 Iot to connect to Blynk's servers and read data from these sensors. The experiment was set up as follows:<br>
                    <img src="../img/projects/Sensors_bynk/Optimized-sensors.JPG" class="inner-img-landscape" alt="Sensors"><br>
                    <img src="../img/projects/Sensors_bynk/Optimized-sensors-setup.JPG" class="inner-img-portrait" alt="Setup"><br>
                    I used an old camera tripod to mount the sensors onto, because they needed to be held securely and all at the same height for it to be a fair experiment. I also fixed a breadboard and the Arduino to the tripod, because there was no need to find a more permenent solution.<br><br>

                    Blynk provides some good documentation for most of its services, which made it very easy to write code for the Arduino to connect to the mobile Blynk app which is where the data would be displayed. As opposed to normal GPIO Pins, Blynk makes use of a concept called Virtual Pins (VPs) which work similarly to harware pins, but are obviously virtual. This meanse that there is almost no limit to the number of virtual pins one can use. These pins are a way for the Arduino to interface with the Blynk cloud.<br><br>

                    Using VPs, I used Blynk's free app to build a project layout that listened for input to these VPs from the Arduino. This app gives the user control over exactly what kind of controls or interfaces he/she want to see in the project layout and I set it up as follows:<br><br>
                    <img src="../img/projects/Sensors_bynk/Optimized-blynk_app.JPG" class="inner-img-portrait" alt="Blynk_App"><br>

                    In the upper section of the layout, there are three LEDs that light up whenever its respective sensor senses movement. This all happens in real-time, which feels a bit like magic.<br><br>
                    
                    Just below that, I decided to use Blynk's SuperChart widget to display the amount of motion every sensor senses over time. This data is what I was interested in and after completing testing, this data can be exported to CSV format, perfect for analyzing in Excel.<br><br>
                    
                    The lower half of the screen contains a table which is also updated live and shows the number of times every sensor was triggered and what each sensor's delay time was when it was last triggered.<br><br>

                    Having set up the experiment, I started testing by repeating a series of movements infront of these sensors at different distances away. After each iteration, I exported the data and repeated at the new distance. I knew all three sensors worked almost identically well at the datum, 0.5m away. In this way, I could use the data to compare how each sensor performs against its own datum at different distances.<br><br>

                    I used Excel to convert the data into a workable format and plotted the results in the graph below:<br><br>
                    <img src="../img/projects/Sensors_bynk/graph.PNG" class="inner-img-landscape" alt="Graph"><br>

                    Clearly, the HC-SR501 PIR sensor works best at a longer range, unlike the other two. The results of this experiment may not be extemely useful to me (until I find an appropriate use case), but the goal was to test the capabilities of Blynk and I am very happy with it. Everything that I used it for could be done locally within the arduino script, but the power of Blynk really shows when you want to add wireless control to IoT projects.
                    </p>
                    
                </div>
            </section>
        </div>

        <div class="cloak cloak5 hidden">
            <section id="project5" class="project">
                <div class="cover cover5"></div>
                <div class="text">
                    <h1 class="title">Stepper Motor Control with ESP32, Arduino and AWS IoT Core</h1>
                    <p class="intro">In this project, I controlled a stepper motor and driver using an ESP32 with the Arduino IDE. The ESP32 received input from its relevant topics on AWS Iot. Depending on these inputs, the microcontroller (ESP32) would either turn the motor to the desired location or publish buck to the topics on AWS Iot.</p>
                    <p class="paragraphs"><img class="inner-img-portrait" src="../img//projects/ESP32_AWS/Optimized-ESP32_wiring_annotated.jpg" alt=""><br>The goal of this project was to communicate to the ESP32 board from AWS IoT core. A typical message that would be sent to the board would include an angle that the ESP would have to extract before instructing the stepper motor to move to that exact angle. The motor driver used in this project is the A4988 stepper motor driver. It includes 4 pins that are used to select the motor step size, which allows for a lot of control over the motor's accuracy and speed.<br><br>
                    
                    As with most of my electronics projects, there is a hardware and software side to the problem.<br><br>
                    
                    In this case, the hardware problem was figuring out the correct wiring from the ESP to the stepper driver while ensuring the motor voltage and current would stay inside a safe boundary. This was my first time working with a stepper motor and I thoroughly enjoyed learning how to control it.<br>
                    
                    <img src="../img/projects/ESP32_AWS/Optimized-ESP32_soldering.jpg" alt="soldering" class="inner-img-landscape"><br>
                    
                    The software side of the problem included writing the arduino script that would be flashed to the ESP. This script had to facilitate the communication with AWS IoT core while controlling the motor's angle and speed, but connecting to AWS proved to be a simpler task than I had thought, owing to <a href="https://aws.amazon.com/blogs/compute/building-an-aws-iot-core-device-using-aws-serverless-and-an-esp32/" target="_blank">this</a> helpful guide AWS has published specifically for the ESP32 board. Another thing to consider when writing the script is the math involved with calculating how many pulses to send to the driver and at what frequency, depending on the step-size that was chosen. A higher frequency will casue the motor to turn faster and more pulses cause it to turn further.<br><br>
                    In conclusion, considering that I started this project with little knowledge about AWS IoT Core or controlling stepper motors, I have thoroughly enjoyed the learning curve and it has increased my interest in power electronics as a whole.</p>
                </div>
            </section>
        </div>

        <div class="cloak cloak6 hidden">
            <section id="project6" class="project">
                <div class="cover cover6"></div>
                <div class="text">
                    <h1 class="title">LCD Weather module with Arduino and OpenWeatherMap API</h1>
                    <p class="intro">This DIY weather hub is powered by an Arduino Nano 33 IoT, which displays weather information from the OpenWeatherMap API to a 20x4 LCD screen. The arduino fetches the temperature, wind and precipitation at a chosen time interval, for a pre-determined location.</p>
                    <p class="paragraphs">The goal of this project was for me to learn how API calls are made from an Arduino, to learn how LCD screens are used with Arduinos and to practice my soldering.<br><br>
                    Writing code to display to the LCD screen was really very easy once it was wired correctly. This is made possible by the library, LiquidCrystal.h, which includes intuitive functions like lcd.clear() and lcd.setCursor(). Below is a diagram for wiring the LCD screen correctly:<br>
                    <img src="../img/projects/weather_module/LCD_Wiring.png" alt="LCD_Wiring" class="inner-img-landscape"><br>
                    The potentiometer is useful for adjusting the screen's contrast.<br><br>
                    Some additional features that I have added to this simple diagram are a PIR motion sensor and a BC547 Transistor. These are used to switch the backlight of the LCD on when the sensor is triggered and off again 10 seconds later and the transistor is connected to the anode and cathode pins on the very right of the LCD's diagram above (Transistor not in diagram).<br>
                    <img src="../img/projects/weather_module/Optimized-overview-annotated-procreate.jpg" alt="weather_module" class="inner-img-landscape"><br>
                    <img src="../img/projects/weather_module/Optimized-nano_33_iot.JPG" alt="nano-33-iot_scale" class="inner-img-landscape"><br>
                    The most tricky part of this project was figuring out how to make an API call and deserialize the received Json data. This was made particularly difficult by the fact that the code is different depending on the board you are using. The board I used, the Nano 33 IoT, is still a relatively new product which is why it lacks the kind of online support that can be found for older wireless boards like the ESP8266. However, the effort I had to put in to write working code has taught me much more than I would have learned otherwise.</p>
                </div>
            </section>
        </div>
        
    </main>

   
    
    
</body>
</html>